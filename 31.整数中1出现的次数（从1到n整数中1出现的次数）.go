package main

import "fmt"

/*
题目描述
求出1~13的整数中1出现的次数,并算出100~1300的整数中1出现的次数？
为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。
ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数（从1 到 n 中1出现的次数）。
*/
func main() {
	//fmt.Println(NumberOf1Between1AndN_Solution1(99999999999))
	fmt.Println(NumberOf1Between1AndN_Solution2(999))
}

func NumberOf1Between1AndN_Solution1(n int) (res int) {
	for i := 1; i <= n; i++ {
		num := i
		for {
			if num == 0 {
				break
			}
			if num%10 == 1 {
				res++
			}
			num = num / 10
		}
	}
	return res
}

/*


总结一下以上的算法，可以看到，当计算右数第 i 位包含的 X 的个数时：
取第 i 位左边（高位）的数字，乘以 10i−1，得到基础值 a。
取第 i 位数字，计算修正值：
如果大于 X，则结果为 a+10i−1。
如果小于 X，则结果为 a。
如果等 X，则取第 i 位右边（低位）数字，设为 b，最后结果为 a+b+1。
*/
func NumberOf1Between1AndN_Solution2(n int) int {
	count := 0
	for i := 1; i <= n; i *= 10 {
		a := n / i
		b := n % i
		//之所以补8，是因为当百位为0，则a/10==(a+8)/10，
		//当百位>=2，补8会产生进位位，效果等同于(a/10+1)
		count += (a + 8) / 10 * i
		if a%10 == 1 {
			// 如果是1xx...,就会有 b+1 个1
			count += b + 1
		}
	}
	return count
}

/**
0-9  y 1       1                             1
10-99 xy 19      20  10 + 9 + 1
100-999 280   300  100 +
1000-9999 3700 4000
10000-99999 46000  50000
            550000 600000
            6400000 7000000
            73000000   80000000
            820000000   900000000
            91000000000  10000000000
                         110000000000
                         1200000000000

32451  ->  0->30000   300001->32451
13246  ->  0->10000   100001->13246
*/
